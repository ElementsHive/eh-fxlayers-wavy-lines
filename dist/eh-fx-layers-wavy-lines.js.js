const g = {
  style1: {
    waveTimeMultiplierX: 5e-3,
    waveTimeMultiplierY: 0.01,
    waveFrequencyX: 2e-3,
    waveFrequencyY: 2e-3,
    waveNoiseAmplitude: 6,
    waveHorizontalAmplitude: 12,
    waveVerticalAmplitude: 3,
    mouseInfluenceRadiusBase: 150,
    mouseWaveFrequency: 1e-3,
    mouseInfluenceStrength: 35e-5,
    cursorRestorationForce: 5e-3,
    cursorDamping: 0.95,
    cursorPositionLimit: 100,
    line_gap: 10,
    point_gap: 10,
    axis: "vertical"
  },
  style2: {
    waveTimeMultiplierX: 0.012,
    waveTimeMultiplierY: 4e-3,
    waveFrequencyX: 1e-3,
    waveFrequencyY: 8e-4,
    waveNoiseAmplitude: 12,
    waveHorizontalAmplitude: 12,
    waveVerticalAmplitude: 8,
    mouseInfluenceRadiusBase: 150,
    mouseWaveFrequency: 5e-4,
    mouseInfluenceStrength: 7e-4,
    cursorRestorationForce: 5e-3,
    cursorDamping: 0.98,
    cursorPositionLimit: 50,
    line_gap: 10,
    point_gap: 15,
    axis: "vertical"
  },
  style3: {
    waveTimeMultiplierX: 0.09,
    waveTimeMultiplierY: 1e-3,
    waveFrequencyX: 1e-3,
    waveFrequencyY: 2e-3,
    waveNoiseAmplitude: 4,
    waveHorizontalAmplitude: 32,
    waveVerticalAmplitude: 16,
    mouseInfluenceRadiusBase: 100,
    mouseWaveFrequency: 7e-4,
    mouseInfluenceStrength: 7e-4,
    cursorRestorationForce: 5e-3,
    cursorDamping: 0.97,
    cursorPositionLimit: 50,
    line_gap: 12,
    point_gap: 10,
    axis: "vertical"
  },
  style4: {
    waveTimeMultiplierX: 0.01,
    waveTimeMultiplierY: 5e-3,
    waveFrequencyX: 2e-3,
    waveFrequencyY: 2e-3,
    waveNoiseAmplitude: 6,
    waveHorizontalAmplitude: 3,
    waveVerticalAmplitude: 24,
    mouseInfluenceRadiusBase: 150,
    mouseWaveFrequency: 1e-3,
    mouseInfluenceStrength: 35e-5,
    cursorRestorationForce: 5e-3,
    cursorDamping: 0.95,
    cursorPositionLimit: 100,
    line_gap: 10,
    point_gap: 10,
    axis: "horizontal"
  },
  style5: {
    waveTimeMultiplierX: 4e-3,
    waveTimeMultiplierY: 0.012,
    waveFrequencyX: 8e-4,
    waveFrequencyY: 1e-3,
    waveNoiseAmplitude: 12,
    waveHorizontalAmplitude: 8,
    waveVerticalAmplitude: 12,
    mouseInfluenceRadiusBase: 150,
    mouseWaveFrequency: 5e-4,
    mouseInfluenceStrength: 7e-4,
    cursorRestorationForce: 5e-3,
    cursorDamping: 0.98,
    cursorPositionLimit: 50,
    line_gap: 10,
    point_gap: 15,
    axis: "horizontal"
  },
  style6: {
    waveTimeMultiplierX: 3e-3,
    waveTimeMultiplierY: 0.05,
    waveFrequencyX: 15e-4,
    waveFrequencyY: 2e-3,
    waveNoiseAmplitude: 4,
    waveHorizontalAmplitude: 16,
    waveVerticalAmplitude: 32,
    mouseInfluenceRadiusBase: 100,
    mouseWaveFrequency: 7e-4,
    mouseInfluenceStrength: 7e-4,
    cursorRestorationForce: 5e-3,
    cursorDamping: 0.97,
    cursorPositionLimit: 50,
    line_gap: 12,
    point_gap: 10,
    axis: "horizontal"
  },
  style7: {
    waveTimeMultiplierX: 0.1,
    waveTimeMultiplierY: 0.03,
    waveFrequencyX: 1e-3,
    waveFrequencyY: 4e-4,
    waveNoiseAmplitude: 6,
    waveHorizontalAmplitude: 12,
    waveVerticalAmplitude: 8,
    mouseInfluenceRadiusBase: 150,
    mouseWaveFrequency: 2e-5,
    mouseInfluenceStrength: 2e-4,
    cursorRestorationForce: 5e-3,
    cursorDamping: 0.95,
    cursorPositionLimit: 50,
    line_gap: 100,
    point_gap: 15,
    axis: "horizontal"
  },
  style8: {
    waveTimeMultiplierX: 0.2,
    waveTimeMultiplierY: 0.1,
    waveFrequencyX: 1e-4,
    waveFrequencyY: 1e-3,
    waveNoiseAmplitude: 6,
    waveHorizontalAmplitude: 1,
    waveVerticalAmplitude: 24,
    mouseInfluenceRadiusBase: 200,
    mouseWaveFrequency: 2e-5,
    mouseInfluenceStrength: 1e-4,
    cursorRestorationForce: 7e-3,
    cursorDamping: 0.97,
    cursorPositionLimit: 100,
    line_gap: 100,
    point_gap: 15,
    axis: "horizontal"
  },
  style9: {
    waveTimeMultiplierX: 0.1,
    waveTimeMultiplierY: 0.1,
    waveFrequencyX: 1e-3,
    waveFrequencyY: 5e-4,
    waveNoiseAmplitude: 6,
    waveHorizontalAmplitude: 24,
    waveVerticalAmplitude: 1,
    mouseInfluenceRadiusBase: 150,
    mouseWaveFrequency: 1e-5,
    mouseInfluenceStrength: 2e-4,
    cursorRestorationForce: 5e-3,
    cursorDamping: 0.95,
    cursorPositionLimit: 100,
    line_gap: 100,
    point_gap: 15,
    axis: "vertical"
  },
  style10: {
    waveTimeMultiplierX: 0.1,
    waveTimeMultiplierY: 0.03,
    waveFrequencyX: 5e-4,
    waveFrequencyY: 1e-3,
    waveNoiseAmplitude: 6,
    waveHorizontalAmplitude: 1,
    waveVerticalAmplitude: 24,
    mouseInfluenceRadiusBase: 200,
    mouseWaveFrequency: 15e-6,
    mouseInfluenceStrength: 1e-4,
    cursorRestorationForce: 7e-3,
    cursorDamping: 0.97,
    cursorPositionLimit: 100,
    line_gap: 100,
    point_gap: 10,
    axis: "horizontal"
  },
  style11: {
    waveTimeMultiplierX: 0.03,
    waveTimeMultiplierY: 0.1,
    waveFrequencyX: 4e-4,
    waveFrequencyY: 1e-3,
    waveNoiseAmplitude: 6,
    waveHorizontalAmplitude: 8,
    waveVerticalAmplitude: 12,
    mouseInfluenceRadiusBase: 150,
    mouseWaveFrequency: 2e-5,
    mouseInfluenceStrength: 1e-4,
    cursorRestorationForce: 5e-3,
    cursorDamping: 0.95,
    cursorPositionLimit: 50,
    line_gap: 100,
    point_gap: 15,
    axis: "vertical"
  },
  style12: {
    waveTimeMultiplierX: 0.1,
    waveTimeMultiplierY: 0.2,
    waveFrequencyX: 1e-3,
    waveFrequencyY: 1e-4,
    waveNoiseAmplitude: 6,
    waveHorizontalAmplitude: 24,
    waveVerticalAmplitude: 1,
    mouseInfluenceRadiusBase: 150,
    mouseWaveFrequency: 1e-5,
    mouseInfluenceStrength: 2e-4,
    cursorRestorationForce: 5e-3,
    cursorDamping: 0.95,
    cursorPositionLimit: 100,
    line_gap: 100,
    point_gap: 15,
    axis: "vertical"
  }
};
function I(o, e = null) {
  let t = o;
  if (o === "random") {
    const n = Object.keys(g), s = Math.floor(Math.random() * n.length);
    t = n[s];
  } else if (o === "random_complex") {
    const n = ["style1", "style2", "style3", "style4", "style5", "style6"], s = Math.floor(Math.random() * n.length);
    t = n[s];
  } else if (o === "random_simple") {
    const n = ["style7", "style8", "style9", "style10", "style11", "style12"], s = Math.floor(Math.random() * n.length);
    t = n[s];
  }
  const i = { ...g[t] || g.style1 };
  return e && (["style7", "style8", "style9"].includes(t) ? e.width < 500 ? i.line_gap = 25 : e.width < 1e3 && (i.line_gap = 50) : ["style10", "style11", "style12"].includes(t) && (e.height < 300 ? i.line_gap = 25 : e.height < 500 && (i.line_gap = 50))), i;
}
const A = `const L = /* @__PURE__ */ Math.sqrt(3), V = 0.5 * (L - 1), g = (3 - L) / 6, z = (o) => Math.floor(o) | 0, S = /* @__PURE__ */ new Float64Array([
  1,
  1,
  -1,
  1,
  1,
  -1,
  -1,
  -1,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1,
  0,
  0,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1
]);
function B(o = Math.random) {
  const i = H(o), t = new Float64Array(i).map((s) => S[s % 12 * 2]), e = new Float64Array(i).map((s) => S[s % 12 * 2 + 1]);
  return function(r, m) {
    let u = 0, n = 0, f = 0;
    const p = (r + m) * V, A = z(r + p), q = z(m + p), I = (A + q) * g, W = A - I, N = q - I, c = r - W, l = m - N;
    let F, M;
    c > l ? (F = 1, M = 0) : (F = 0, M = 1);
    const R = c - F + g, T = l - M + g, _ = c - 1 + 2 * g, P = l - 1 + 2 * g, X = A & 255, Y = q & 255;
    let v = 0.5 - c * c - l * l;
    if (v >= 0) {
      const a = X + i[Y], h = t[a], d = e[a];
      v *= v, u = v * v * (h * c + d * l);
    }
    let w = 0.5 - R * R - T * T;
    if (w >= 0) {
      const a = X + F + i[Y + M], h = t[a], d = e[a];
      w *= w, n = w * w * (h * R + d * T);
    }
    let y = 0.5 - _ * _ - P * P;
    if (y >= 0) {
      const a = X + 1 + i[Y + 1], h = t[a], d = e[a];
      y *= y, f = y * y * (h * _ + d * P);
    }
    return 70 * (u + n + f);
  };
}
function H(o) {
  const t = new Uint8Array(512);
  for (let e = 0; e < 512 / 2; e++)
    t[e] = e;
  for (let e = 0; e < 512 / 2 - 1; e++) {
    const s = e + ~~(o() * (256 - e)), r = t[e];
    t[e] = t[s], t[s] = r;
  }
  for (let e = 256; e < 512; e++)
    t[e] = t[e - 256];
  return t;
}
const D = {
  style1: {
    waveTimeMultiplierX: 5e-3,
    waveTimeMultiplierY: 0.01,
    waveFrequencyX: 2e-3,
    waveFrequencyY: 2e-3,
    waveNoiseAmplitude: 6,
    waveHorizontalAmplitude: 12,
    waveVerticalAmplitude: 3,
    mouseInfluenceRadiusBase: 150,
    mouseWaveFrequency: 1e-3,
    mouseInfluenceStrength: 35e-5,
    cursorRestorationForce: 5e-3,
    cursorDamping: 0.95,
    cursorPositionLimit: 100,
    line_gap: 10,
    point_gap: 10,
    axis: "vertical"
  },
  style2: {
    waveTimeMultiplierX: 0.012,
    waveTimeMultiplierY: 4e-3,
    waveFrequencyX: 1e-3,
    waveFrequencyY: 8e-4,
    waveNoiseAmplitude: 12,
    waveHorizontalAmplitude: 12,
    waveVerticalAmplitude: 8,
    mouseInfluenceRadiusBase: 150,
    mouseWaveFrequency: 5e-4,
    mouseInfluenceStrength: 7e-4,
    cursorRestorationForce: 5e-3,
    cursorDamping: 0.98,
    cursorPositionLimit: 50,
    line_gap: 10,
    point_gap: 15,
    axis: "vertical"
  },
  style3: {
    waveTimeMultiplierX: 0.09,
    waveTimeMultiplierY: 1e-3,
    waveFrequencyX: 1e-3,
    waveFrequencyY: 2e-3,
    waveNoiseAmplitude: 4,
    waveHorizontalAmplitude: 32,
    waveVerticalAmplitude: 16,
    mouseInfluenceRadiusBase: 100,
    mouseWaveFrequency: 7e-4,
    mouseInfluenceStrength: 7e-4,
    cursorRestorationForce: 5e-3,
    cursorDamping: 0.97,
    cursorPositionLimit: 50,
    line_gap: 12,
    point_gap: 10,
    axis: "vertical"
  },
  style4: {
    waveTimeMultiplierX: 0.01,
    waveTimeMultiplierY: 5e-3,
    waveFrequencyX: 2e-3,
    waveFrequencyY: 2e-3,
    waveNoiseAmplitude: 6,
    waveHorizontalAmplitude: 3,
    waveVerticalAmplitude: 24,
    mouseInfluenceRadiusBase: 150,
    mouseWaveFrequency: 1e-3,
    mouseInfluenceStrength: 35e-5,
    cursorRestorationForce: 5e-3,
    cursorDamping: 0.95,
    cursorPositionLimit: 100,
    line_gap: 10,
    point_gap: 10,
    axis: "horizontal"
  },
  style5: {
    waveTimeMultiplierX: 4e-3,
    waveTimeMultiplierY: 0.012,
    waveFrequencyX: 8e-4,
    waveFrequencyY: 1e-3,
    waveNoiseAmplitude: 12,
    waveHorizontalAmplitude: 8,
    waveVerticalAmplitude: 12,
    mouseInfluenceRadiusBase: 150,
    mouseWaveFrequency: 5e-4,
    mouseInfluenceStrength: 7e-4,
    cursorRestorationForce: 5e-3,
    cursorDamping: 0.98,
    cursorPositionLimit: 50,
    line_gap: 10,
    point_gap: 15,
    axis: "horizontal"
  },
  style6: {
    waveTimeMultiplierX: 3e-3,
    waveTimeMultiplierY: 0.05,
    waveFrequencyX: 15e-4,
    waveFrequencyY: 2e-3,
    waveNoiseAmplitude: 4,
    waveHorizontalAmplitude: 16,
    waveVerticalAmplitude: 32,
    mouseInfluenceRadiusBase: 100,
    mouseWaveFrequency: 7e-4,
    mouseInfluenceStrength: 7e-4,
    cursorRestorationForce: 5e-3,
    cursorDamping: 0.97,
    cursorPositionLimit: 50,
    line_gap: 12,
    point_gap: 10,
    axis: "horizontal"
  },
  style7: {
    waveTimeMultiplierX: 0.1,
    waveTimeMultiplierY: 0.03,
    waveFrequencyX: 1e-3,
    waveFrequencyY: 4e-4,
    waveNoiseAmplitude: 6,
    waveHorizontalAmplitude: 12,
    waveVerticalAmplitude: 8,
    mouseInfluenceRadiusBase: 150,
    mouseWaveFrequency: 2e-5,
    mouseInfluenceStrength: 2e-4,
    cursorRestorationForce: 5e-3,
    cursorDamping: 0.95,
    cursorPositionLimit: 50,
    line_gap: 100,
    point_gap: 15,
    axis: "horizontal"
  },
  style8: {
    waveTimeMultiplierX: 0.2,
    waveTimeMultiplierY: 0.1,
    waveFrequencyX: 1e-4,
    waveFrequencyY: 1e-3,
    waveNoiseAmplitude: 6,
    waveHorizontalAmplitude: 1,
    waveVerticalAmplitude: 24,
    mouseInfluenceRadiusBase: 200,
    mouseWaveFrequency: 2e-5,
    mouseInfluenceStrength: 1e-4,
    cursorRestorationForce: 7e-3,
    cursorDamping: 0.97,
    cursorPositionLimit: 100,
    line_gap: 100,
    point_gap: 15,
    axis: "horizontal"
  },
  style9: {
    waveTimeMultiplierX: 0.1,
    waveTimeMultiplierY: 0.1,
    waveFrequencyX: 1e-3,
    waveFrequencyY: 5e-4,
    waveNoiseAmplitude: 6,
    waveHorizontalAmplitude: 24,
    waveVerticalAmplitude: 1,
    mouseInfluenceRadiusBase: 150,
    mouseWaveFrequency: 1e-5,
    mouseInfluenceStrength: 2e-4,
    cursorRestorationForce: 5e-3,
    cursorDamping: 0.95,
    cursorPositionLimit: 100,
    line_gap: 100,
    point_gap: 15,
    axis: "vertical"
  },
  style10: {
    waveTimeMultiplierX: 0.1,
    waveTimeMultiplierY: 0.03,
    waveFrequencyX: 5e-4,
    waveFrequencyY: 1e-3,
    waveNoiseAmplitude: 6,
    waveHorizontalAmplitude: 1,
    waveVerticalAmplitude: 24,
    mouseInfluenceRadiusBase: 200,
    mouseWaveFrequency: 15e-6,
    mouseInfluenceStrength: 1e-4,
    cursorRestorationForce: 7e-3,
    cursorDamping: 0.97,
    cursorPositionLimit: 100,
    line_gap: 100,
    point_gap: 10,
    axis: "horizontal"
  },
  style11: {
    waveTimeMultiplierX: 0.03,
    waveTimeMultiplierY: 0.1,
    waveFrequencyX: 4e-4,
    waveFrequencyY: 1e-3,
    waveNoiseAmplitude: 6,
    waveHorizontalAmplitude: 8,
    waveVerticalAmplitude: 12,
    mouseInfluenceRadiusBase: 150,
    mouseWaveFrequency: 2e-5,
    mouseInfluenceStrength: 1e-4,
    cursorRestorationForce: 5e-3,
    cursorDamping: 0.95,
    cursorPositionLimit: 50,
    line_gap: 100,
    point_gap: 15,
    axis: "vertical"
  },
  style12: {
    waveTimeMultiplierX: 0.1,
    waveTimeMultiplierY: 0.2,
    waveFrequencyX: 1e-3,
    waveFrequencyY: 1e-4,
    waveNoiseAmplitude: 6,
    waveHorizontalAmplitude: 24,
    waveVerticalAmplitude: 1,
    mouseInfluenceRadiusBase: 150,
    mouseWaveFrequency: 1e-5,
    mouseInfluenceStrength: 2e-4,
    cursorRestorationForce: 5e-3,
    cursorDamping: 0.95,
    cursorPositionLimit: 100,
    line_gap: 100,
    point_gap: 15,
    axis: "vertical"
  }
};
function b(o, i = null) {
  let t = o;
  const e = { ...D[t] || D.style1 };
  return i && (["style7", "style8", "style9"].includes(t) ? i.width < 500 ? e.line_gap = 25 : i.width < 1e3 && (e.line_gap = 50) : ["style10", "style11", "style12"].includes(t) && (i.height < 300 ? e.line_gap = 25 : i.height < 500 && (e.line_gap = 50))), e;
}
class k {
  constructor() {
    this.noise = B(), this.lines = [], this.axis = "vertical", this.direction = "forward", this.directionMultiplier = -1, this.mouse = {
      sx: 0,
      sy: 0,
      vs: 0,
      a: 0
    }, this.applyPreset(b("style1"));
  }
  /**
   * Apply a wave animation preset
   * @param {string} preset
   */
  applyPreset(i) {
    Object.assign(this, i);
  }
  initLines(i, t = "vertical", e = "forward") {
    this.axis = t, this.updateDirection(e), this.lines = i.map(
      (s) => s.map((r) => ({
        ...r,
        wave: { x: 0, y: 0 },
        cursor: { x: 0, y: 0, vx: 0, vy: 0 }
      }))
    );
  }
  updateDirection(i) {
    this.direction = i, this.directionMultiplier = i === "forward" ? -1 : 1;
  }
  updateMouse(i) {
    const t = {
      sx: i.smoothX,
      sy: i.smoothY,
      vs: i.smoothVelocity,
      a: i.angle
    };
    this.mouse = { ...this.mouse, ...t };
  }
  movePoints(i) {
    this.lines.forEach((t) => {
      t.forEach((e) => {
        const s = this.noise(
          (e.x + i * this.waveTimeMultiplierX * this.directionMultiplier) * this.waveFrequencyX,
          (e.y + i * this.waveTimeMultiplierY * this.directionMultiplier) * this.waveFrequencyY
        ) * this.waveNoiseAmplitude;
        e.wave.x = Math.cos(s) * this.waveHorizontalAmplitude, e.wave.y = Math.sin(s) * this.waveVerticalAmplitude;
        const r = e.x - this.mouse.sx, m = e.y - this.mouse.sy, u = Math.hypot(r, m), n = Math.max(this.mouseInfluenceRadiusBase, this.mouse.vs);
        if (u < n) {
          const f = 1 - u / n, p = Math.cos(u * this.mouseWaveFrequency) * f;
          e.cursor.vx += Math.cos(this.mouse.a) * p * n * this.mouse.vs * this.mouseInfluenceStrength, e.cursor.vy += Math.sin(this.mouse.a) * p * n * this.mouse.vs * this.mouseInfluenceStrength;
        }
        e.cursor.vx += (0 - e.cursor.x) * this.cursorRestorationForce, e.cursor.vy += (0 - e.cursor.y) * this.cursorRestorationForce, e.cursor.vx *= this.cursorDamping, e.cursor.vy *= this.cursorDamping, e.cursor.x += e.cursor.vx, e.cursor.y += e.cursor.vy, e.cursor.x = Math.min(this.cursorPositionLimit, Math.max(-this.cursorPositionLimit, e.cursor.x)), e.cursor.y = Math.min(this.cursorPositionLimit, Math.max(-this.cursorPositionLimit, e.cursor.y));
      });
    });
  }
  calculatePaths() {
    return this.lines.map((i) => {
      if (i.length < 2) return "";
      const t = {
        x: i[0].x + i[0].wave.x,
        y: i[0].y + i[0].wave.y
      };
      let e = \`M \${t.x} \${t.y}\`;
      for (let s = 1; s < i.length; s++) {
        const r = {
          x: i[s].x + i[s].wave.x + i[s].cursor.x,
          y: i[s].y + i[s].wave.y + i[s].cursor.y
        };
        e += \`L \${r.x} \${r.y}\`;
      }
      return e;
    });
  }
  processFrame(i) {
    const { time: t, mouseData: e } = i;
    return this.updateMouse(e), this.movePoints(t), {
      type: "frame-result",
      pathData: this.calculatePaths()
    };
  }
}
const x = new k();
self.addEventListener("message", (o) => {
  const { type: i, data: t } = o.data;
  try {
    switch (i) {
      case "init":
        x.initLines(t.lines, t.axis, t.direction), self.postMessage({ type: "init-complete" });
        break;
      case "process-frame":
        const e = x.processFrame(t);
        self.postMessage(e);
        break;
      case "apply-preset":
        x.applyPreset(t.preset), self.postMessage({ type: "preset-applied", preset: t.preset });
        break;
      case "update-direction":
        x.updateDirection(t.direction), self.postMessage({ type: "direction-updated", direction: t.direction });
        break;
      default:
        console.warn("Unknown message type:", i);
    }
  } catch (e) {
    self.postMessage({
      type: "error",
      error: e.message
    });
  }
});
`, M = typeof self < "u" && self.Blob && new Blob(["URL.revokeObjectURL(import.meta.url);", A], { type: "text/javascript;charset=utf-8" });
function x(o) {
  let e;
  try {
    if (e = M && (self.URL || self.webkitURL).createObjectURL(M), !e) throw "";
    const t = new Worker(e, {
      type: "module",
      name: o?.name
    });
    return t.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(e);
    }), t;
  } catch {
    return new Worker(
      "data:text/javascript;charset=utf-8," + encodeURIComponent(A),
      {
        type: "module",
        name: o?.name
      }
    );
  }
}
const a = window.ElementsHiveUtils.mouse, { isElementInViewport: P } = window.ElementsHiveUtils, { getResponsiveControlValue: d } = window.ElementsHiveUtils.breakdance, { safeMergeObjects: _ } = window.ElementsHiveUtils.utils, R = {
  parent: null,
  container: null,
  svgEl: null,
  preset: {
    breakpoint_base: "style1"
  },
  direction: "forward",
  wave_animation: {
    breakpoint_base: "enabled"
  },
  mouse_effect: {
    breakpoint_base: "enabled"
  }
};
class b {
  /**
   * Creates a new Interactive 2D Waves instance with Web Worker optimization.
   *
   * @param {Object} options - Configuration options for the waves effect
   * @param {string} options.id - The id of the waves effect layer
   * @param {HTMLElement} options.containerEl - The DOM element to contain the waves effect
   * @param {SVGElement} options.svg - The SVG element to use for the waves effect
   * @param {string} [options.direction='forward'] - Wave direction: 'forward' (negative values) or 'backward' (positive values)
   * @param {string} [options.preset='style1'] - Wave animation preset: 'style1', 'style2', 'style3', 'style4', 'style5', 'style6', 'style7', 'style8', 'style9', 'style10', 'style11', 'style12', or 'random' (includes axis, line_gap and point_gap)
   * @param {string} [options.wave_animation='enabled'] - Controls wave animations: 'enabled' or 'disabled'
   * @param {string} [options.mouse_effect='disabled'] - Controls mouse interaction effects: 'enabled' or 'disabled'
   *
   */
  constructor(e) {
    this.options = _(R, e), this.parent = this.options.parent, this.container = this.options.container, this.svgEl = this.options.svgEl, this.direction = this.options.direction, this.currentPresentName = d(this.options.preset), this.mouse = {
      x: 0,
      y: 0,
      velocity: 0,
      smoothVelocity: 0,
      angle: 0
    }, this.paths = [], this.lines = [], this.workerReady = !1, this.isInitializing = !0, this.staticTime = null, this.onResizeHandler = this.onResize.bind(this), this.tick = this.tick.bind(this), this.onWorkerMessage = this.onWorkerMessage.bind(this), this.updateMousePositionHandler = this.updateMousePosition.bind(this), this.setBoundsHandler = this.setBounds.bind(this), this.init();
  }
  setResponsiveValues() {
    this.currentPreset = I(d(this.options.preset), this.bounds), this.wave_animation = d(this.options.wave_animation), this.mouse_effect = d(this.options.mouse_effect);
  }
  /**
   * Initializes the waves effect by setting up DOM, worker, and event listeners.
   *
   * @private
   * @throws {Error} When worker initialization fails
   */
  init() {
    this.initEvents(), this.setBounds(), this.setResponsiveValues(), this.setSize(), this.setLines(), this.initWorker(), this.wave_animation === "enabled" ? this.rafId = requestAnimationFrame(this.tick.bind(this)) : this.processStaticFrame(), P(this.parent) && this.onPointerEnter();
  }
  /**
   * Sets the bounds of the container.
   *
   * @private
   */
  setBounds() {
    this.bounds = this.container.getBoundingClientRect();
  }
  /**
   * Sets the size of the SVG element based on container dimensions.
   *
   * @private
   */
  setSize() {
    this.svgEl.style.width = `${this.bounds.width}px`, this.svgEl.style.height = `${this.bounds.height}px`;
  }
  /**
   * Creates the wave lines and points based on container dimensions and axis orientation.
   *
   * @private
   */
  setLines() {
    this.svgEl.innerHTML = "";
    const { width: e, height: t } = this.bounds;
    this.lines = [], this.paths = [];
    const n = (this.currentPreset.axis || "vertical") === "vertical", s = this.currentPreset.line_gap, r = this.currentPreset.point_gap, h = e + 200, F = t + 200;
    if (n) {
      const m = Math.ceil(h / s), p = Math.ceil(F / r), w = (e - s * m) / 2, f = (t - r * p) / 2;
      for (let l = 0; l < m; l++) {
        const v = [];
        for (let c = 0; c < p; c++) {
          const y = {
            x: w + s * l,
            y: f + r * c,
            wave: { x: 0, y: 0 },
            cursor: { x: 0, y: 0, vx: 0, vy: 0 }
          };
          v.push(y);
        }
        const u = document.createElementNS("http://www.w3.org/2000/svg", "path");
        u.classList.add("eh-fx-layers__layer-wavy_lines__line"), this.svgEl.appendChild(u), this.paths.push(u), this.lines.push(v);
      }
    } else {
      const m = Math.ceil(F / s), p = Math.ceil(h / r), w = (e - r * p) / 2, f = (t - s * m) / 2;
      for (let l = 0; l < m; l++) {
        const v = [];
        for (let c = 0; c < p; c++) {
          const y = {
            x: w + r * c,
            y: f + s * l,
            wave: { x: 0, y: 0 },
            cursor: { x: 0, y: 0, vx: 0, vy: 0 }
          };
          v.push(y);
        }
        const u = document.createElementNS("http://www.w3.org/2000/svg", "path");
        u.classList.add("eh-fx-layers__layer-wavy_lines__line"), this.svgEl.appendChild(u), this.paths.push(u), this.lines.push(v);
      }
    }
  }
  /**
   * Initializes the Web Worker for computational tasks.
   *
   * @private
   * @throws {Error} When worker creation or initialization fails
   */
  initWorker() {
    this.worker = new x(), this.worker.addEventListener("message", this.onWorkerMessage), this.worker.addEventListener("error", (e) => {
      throw new Error(`Worker error: ${e.message}`);
    }), this.lines.length > 0 && this.sendToWorker("init", {
      lines: this.lines,
      axis: this.currentPreset.axis || "vertical",
      direction: this.direction
    }), this.sendToWorker("apply-preset", { preset: this.currentPreset });
  }
  /**
   * Sends a message to the Web Worker.
   *
   * @param {string} type - The message type
   * @param {Object} data - The data to send to the worker
   * @private
   */
  sendToWorker(e, t) {
    this.worker && this.worker.postMessage({ type: e, data: t });
  }
  /**
   * Handles messages from the Web Worker.
   *
   * @param {MessageEvent} event - The message event from the worker
   * @private
   * @throws {Error} When worker reports processing errors
   */
  onWorkerMessage(e) {
    const { type: t, pathData: i, error: n } = e.data;
    switch (t) {
      case "init-complete":
        this.workerReady = !0, this.isInitializing && (this.isInitializing = !1, this.wave_animation === "disabled" && this.processStaticFrame());
        break;
      case "frame-result":
        i && this.updatePaths(i);
        break;
      case "error":
        throw new Error(`Worker processing error: ${n}`);
    }
  }
  /**
   * Updates SVG path data.
   *
   * @param {string[]} pathData - Array of SVG path data strings
   * @private
   */
  updatePaths(e) {
    e.forEach((t, i) => {
      this.paths[i] && t && this.paths[i].getAttribute("d") !== t && this.paths[i].setAttribute("d", t);
    });
  }
  /**
   * Handles container resize by updating size, recreating lines, and updating the worker.
   *
   * @private
   */
  onResize() {
    const e = this.wave_animation, t = this.mouse_effect, i = this.currentPresentName;
    this.currentPresentName = d(this.options.preset), this.setBounds(), this.setResponsiveValues();
    const n = e !== this.wave_animation, s = t !== this.mouse_effect, r = i !== this.currentPresentName, h = this.wave_animation === "enabled";
    this.setSize(), r && this.worker && this.sendToWorker("apply-preset", { preset: this.currentPreset }), this.setLines(), this.staticTime = null, this.worker && this.workerReady && this.sendToWorker("init", {
      lines: this.lines,
      axis: this.currentPreset.axis || "vertical",
      direction: this.direction
    }), t !== this.mouse_effect && (this.mouse_effect === "enabled" || (this.removeMouseMoveListener(), this.wave_animation === "disabled" && this.rafId && (cancelAnimationFrame(this.rafId), this.rafId = null))), (n || s) && (h && !this.rafId ? this.rafId = requestAnimationFrame(this.tick.bind(this)) : !h && this.rafId && (cancelAnimationFrame(this.rafId), this.rafId = null)), this.wave_animation === "disabled" && this.workerReady && this.processStaticFrame();
  }
  /**
   * Main animation loop that triggers worker processing.
   *
   * @param {number} time - The current animation timestamp
   * @private
   */
  tick(e) {
    if (this.workerReady) {
      const t = this.wave_animation === "disabled" ? this.staticTime : e;
      this.sendFrameToWorker(t);
    }
    this.rafId = requestAnimationFrame(this.tick);
  }
  /**
   * Processes a single static frame with random time when animation is disabled.
   * This creates a static wave pattern that doesn't change over time.
   *
   * @private
   */
  processStaticFrame() {
    this.workerReady && (this.staticTime === null && (this.staticTime = Date.now() + Math.random() * 1e4), this.sendFrameToWorker(this.staticTime));
  }
  /**
   * Updates mouse position using Elements Hive mouse utility.
   *
   * @private
   */
  updateMousePosition() {
    this.mouse.x = a.targetPosition.x - this.bounds.left, this.mouse.y = a.targetPosition.y - this.bounds.top;
    const e = a.targetPosition.x - a.lastPosition.x, t = a.targetPosition.y - a.lastPosition.y, i = Math.hypot(e, t);
    this.mouse.velocity = i, this.mouse.smoothVelocity += (i - this.mouse.smoothVelocity) * 0.1, this.mouse.smoothVelocity = Math.min(100, this.mouse.smoothVelocity), this.mouse.angle = Math.atan2(t, e);
  }
  /**
   * Sends current frame data to worker.
   *
   * @param {number} time - The current animation time
   * @private
   */
  sendFrameToWorker(e) {
    const t = {
      time: e,
      mouseData: this.mouse_effect === "enabled" ? {
        smoothX: this.mouse.x,
        smoothY: this.mouse.y,
        smoothVelocity: this.mouse.smoothVelocity,
        angle: this.mouse.angle
      } : {
        smoothX: 0,
        smoothY: 0,
        smoothVelocity: 0,
        angle: 0
      }
    };
    this.sendToWorker("process-frame", t);
  }
  /**
   * Updates the configuration options for the waves effect.
   *
   * @param {Object} newOptions - New options to merge with existing configuration
   * @param {string} [newOptions.direction] - New wave direction: 'forward' (negative values) or 'backward' (positive values)
   * @param {string} [newOptions.preset] - New wave animation preset: 'style1', 'style2', 'style3', 'style4', 'style5', 'style6', 'style7', 'style8', 'style9', 'style10', 'style11', 'style12', or 'random' (includes axis, line_gap and point_gap configuration)
   * @param {string} [newOptions.wave_animation] - Controls wave animations: 'enabled' or 'disabled'
   * @param {string} [newOptions.mouse_effect] - Controls mouse interaction effects: 'enabled' or 'disabled'
   * @public
   */
  updateOptions(e) {
    const t = _(this.options, e);
    this.options = t;
    const i = this.currentPreset, n = this.direction, s = this.mouse_effect, r = this.wave_animation;
    this.setResponsiveValues(), e.hasOwnProperty("preset") && this.currentPreset != i && this.worker && (this.sendToWorker("apply-preset", { preset: this.currentPreset }), this.staticTime = null), e.hasOwnProperty("direction") && e.direction != n && (this.direction = e.direction, this.staticTime = null), this.setLines(), this.staticTime = null, this.worker && (this.sendToWorker("init", {
      lines: this.lines,
      axis: this.currentPreset.axis || "vertical",
      direction: this.direction
    }), this.wave_animation === "disabled" && this.mouse_effect === "disabled" && this.workerReady && this.processStaticFrame()), e.hasOwnProperty("mouse_effect") && this.mouse_effect != s && (this.mouse_effect === "enabled" || (this.removeMouseMoveListener(), this.wave_animation === "disabled" && this.rafId && (cancelAnimationFrame(this.rafId), this.rafId = null, this.processStaticFrame()))), e.hasOwnProperty("wave_animation") && this.wave_animation != r && (this.wave_animation === "enabled" && !this.rafId ? this.rafId = requestAnimationFrame(this.tick.bind(this)) : this.wave_animation === "disabled" && this.rafId && this.mouse_effect === "disabled" && (cancelAnimationFrame(this.rafId), this.rafId = null, this.processStaticFrame()));
  }
  /**
   * Initializes event listeners including resize observer.
   * Creates a resize observer on the container to reinit the grid when the container size changes.
   */
  initEvents() {
    document.addEventListener("scroll", this.setBoundsHandler), window.addEventListener("resize", this.setBoundsHandler), this.initPointerEvents(), this.initIntersectionObserver(), this.initResizeObserver();
  }
  initPointerEvents() {
    this.onPointerEnter = this.onPointerEnter.bind(this), this.onPointerLeave = this.onPointerLeave.bind(this), this.parent.addEventListener("pointerenter", this.onPointerEnter), this.parent.addEventListener("pointerleave", this.onPointerLeave);
  }
  onPointerEnter() {
    this.mouse_effect === "enabled" && (clearTimeout(this.pointerLeaveTimeout), this.setMouseMoveListener(), this.wave_animation === "disabled" && !this.rafId && (this.rafId = requestAnimationFrame(this.tick.bind(this))));
  }
  onPointerLeave() {
    this.pointerLeaveTimeout = setTimeout(() => {
      this.removeMouseMoveListener(), this.wave_animation === "disabled" && this.mouse_effect === "enabled" && this.rafId && (cancelAnimationFrame(this.rafId), this.rafId = null);
    }, 2e3);
  }
  setMouseMoveListener() {
    this.mouse_effect === "enabled" && !this.mouseRafId && (this.mouseRafId = a.on("raf", this.updateMousePositionHandler));
  }
  removeMouseMoveListener() {
    this.mouseRafId && (a.removeListener("raf", this.mouseRafId), this.mouseRafId = null);
  }
  onIntersection(e) {
    e[0].isIntersecting ? this.wave_animation === "enabled" ? this.rafId = requestAnimationFrame(this.tick.bind(this)) : this.processStaticFrame() : (this.rafId && cancelAnimationFrame(this.rafId), this.rafId = null, this.removeMouseMoveListener());
  }
  initIntersectionObserver() {
    const e = {
      root: null,
      rootMargin: "0px",
      threshold: 1e-3
    };
    this.observer = new IntersectionObserver(this.onIntersection.bind(this), e), this.observer.observe(this.container);
  }
  initResizeObserver() {
    this.resizeObserver = new ResizeObserver(() => {
      this.onResizeHandler();
    }), this.resizeObserver.observe(this.container);
  }
  /**
   * Destroys the waves effect instance and cleans up all resources.
   *
   * This method should be called when the component is no longer needed
   * to prevent memory leaks and clean up event listeners.
   *
   * @public
   */
  destroy() {
    this.rafId && (cancelAnimationFrame(this.rafId), this.rafId = null), this.resizeObserver && (this.resizeObserver.disconnect(), this.resizeObserver = null), this.observer && (this.observer.disconnect(), this.observer = null), this.parent && (this.parent.removeEventListener("pointerenter", this.onPointerEnter), this.parent.removeEventListener("pointerleave", this.onPointerLeave)), document.removeEventListener("scroll", this.setBoundsHandler), window.removeEventListener("resize", this.setBoundsHandler), this.removeMouseMoveListener(), this.worker && (this.worker.terminate(), this.worker = null), this.svgEl.innerHTML = "", this.svgEl = null, this.container = null, this.paths = [], this.lines = [], this.bounds = null, this.workerReady = !1;
  }
}
export {
  b as default
};
